# REP-0003: Optimistic Fast Finality

## Preamble
<pre>
REP-0003
Title: Optimistic Fast Finality
Author: Ronin Core Team
Type: Standards Track
Status: Draft
Created: 2023-07-10
</pre>

## Abstract

This REP proposes a new fast finality mechanism that aims to increase the speed of transaction confirmation on Ronin. The proposed mechanism is expected to significantly reduce the time it takes for transactions to be confirmed on Ronin, which will help to improve the user experience and make Ronin more competitive in the market. 

## Rationale

Finality is critical for blockchain security, once the block is finalized, it would not be reverted anymore. The fast finality feature is very useful, users can make sure they get accurate information from the latest finalized block, then they can decide what to do next instantly. 

Currently, to confirm a transaction on Ronin, the users need to wait for 15 blocks (~45s). With the new fast finality mechanism, optimistically, they only need to wait for 2 blocks (~6s) to confirm a transaction. 

## Specification

We propose a voting mechanism to enable optimistic fast finality. 

### Voting rules

Validators confirm a block's validity by providing their signatures on the block's hash. If a block receives enough votes, the validators can create a quorum certificate (QC) to attest to the block's validity. The block's QC is included in its direct child block.

Validators vote according to the following rules:

- **Rule 1:** A validator must not publish two distinct votes for the same height.
- **Rule 2:** A validator must not publish three distinct votes for block $a_i,b_j,a_h$ such that $i < j < h$, and $b_j$ is not a descendant of $a_i$ and $a_h$ is a descendant of $a_i$.
- **Rule 3:** Validators always vote for the latest block of their best chain (i.e., the chain on which they will mine).

### Vote aggregation

Once the validators vote for a block, the next block producer collects those votes and creates a Quorum Certificate (QC) if there are more than $k$ votes for the block. In Ronin's case, with $n=22$ validators, we set $k = \lfloor 2n/3\rfloor+1 = 15$. The QC of a block will be stored in the block header of its direct child. If the validators cannot collect enough votes before the next block is generated, the QC will not be generated.

The QC will be verified by other nodes in the network. A block containing an invalid QC will be considered invalid. To optimize the size and verification time of QCs, we use the [BLS signature scheme](https://github.com/supranational/blst). The BLS signature allows us to aggregate the signatures of validators on a block into a single signature. Compared to unaggregated signatures, the aggregated signature can save up to $n$ times the space. Additionally, we can verify the QC of validators with a single signature verification operation.

### Finality rules

Finalizing a block involves two steps: justification and finalization.

- A block is considered justified if its QC is included in the block header of its direct child.
- A block is considered finalized if it is justified and at least one of its descendants (in the same epoch) is also justified.

### Best chain selection

In Ronin, validators use the sum of the difficulty field to compare and confirm which chain is the best ancestor to pick. This finality mechanism requires the chain to grow under a new fork choice rule.

- The chain that includes the highest justified block is considered the best chain, even if there are other chains with a higher total difficulty.
- If multiple chains include the highest justified block, the chain with the highest total difficulty is selected as the best chain.

### Rewards

At most 1% of the block rewards (including transaction fees and staking rewards) will be distributed to the validators who vote to finalize blocks. Note that, these rewards will not be distributed to the delegators. 

The rewards will be distributed in every period to the validators based on their votes. 

- Let $n_1$ be the number of blocks in the period and $n_2$ be the number of blocks where the QC is included. Let $r$ be the total rewards in the period. The total rewards for all validators for finalizing blocks are $1\%\times r\times n_2/n_1$.
- For every QC that is included in a block, the reward weight of the block producer increases by 2 and the reward weights of the remaining validators, who have their vote included in the QC, increase by 1. The reward of a validator in a period will be proportional her/his reward weight.

### Slash

The validator who violates Rule 1 and Rule 2 will get slashed. 

- The evidence can be submitted by anyone, whenever someone sees the malicious behavior. (We may use the proposal as we did for the double-sign slash)
- The malicious validator will get slashed for 250,000 RON and will be put in jail for $2^{63}-1$ blocks (same as double-sign slash).

## Security analysis


- **Safety**. If a block is finalized, it cannot be reverted, i.e., two blocks in different forks cannot be finalized.
- **Liveness**. New blocks will be added to the chain after some certain time.
- **Fast finality**. A block will be finalized after 2 blocks.

### Safety

If at least $k = \lfloor 2n/3\rfloor+1$ validators are honest, two blocks in different forks cannot both be finalized. 

To prove the theorem, we first show that, two blocks $a_i$ and $b_i$ (are in different forks and the same block height) cannot be both justified. Assume toward contradiction that $a_i$ and $b_i$ are both justified.  In this scenario, there are at least $k$ validators who vote for $a_i$ and $k$ validators who vote for $b_j$. Since the number of malicious validators is at most $n-k$, there are at least $2k-n$ honest validators who vote for $a_i$ and at least $2k-n$ honest validators who vote for $b_j$. Therefore, the total number of votes from honest validators for $a_i$ and $b_j$ is at least. However, since honest validators can only vote for at most one block at a given block height, this case cannot occur.

We now show that blocks $a_{i_1}$ (at block height $i_1$) and $b_{j_1}$ (at block height $j_1$), which are in different forks, cannot be finalized. Assume toward contradiction that two blocks $a_{i_1}$and $b_{j_1}$ are in different forks and are both finalized. Without loss of general, assume $i_1 <j_1$. Let $a_{i_2}$, $b_{j_2}$ be justified descendant blocks of $a_{i_1}, b_{j_1}$, respectively. We consider two cases as follows

- **Case 1:** $i_2<j_2$. In this case, there are at least $k$ validators who vote for $a_{i_1},b_{j_1},a_{i_2}$. Thus, there is at least one honest validator who votes for those 3 blocks. This contradicts Rule 2 for voting.
- **Case 2:** $i_2>j_2$. In this case, there are at least $2k-n$ honest validators who vote for $b_{j_2}$. In the views of those validators, the highest justified block will be $b_{j_1}$. As $j_1 > i_1$, those validators will not vote for block $a_{i_2}$ to finalize block $a_{i_1}$. Therefore, there are at most $3n-3k<k$ validators who vote for $a_{i_2}$. Hence, block $a_{i_2}$ cannot be justified (contradiction).

### Liveness and fast finality

If at least $\lfloor n/2\rfloor+1$ validators are honest and online, the validators can keep producing blocks. 

If at least $k$ validators are honest, and all the votes of honest validators will be received by the next validator within 3s (the block time), then every block will be justified after 1 block. Hence, every block will be finalized after 2 blocks.

## Economic analysis

We will demonstrate that block producers should include all votes in their QC to maximize profits. A rational validator may intentionally exclude the votes of certain validators in an effort to reduce the reward weight of those validators and increase its own rewards. However, if a rational validator does this, the excluded validators may retaliate by also excluding the votes of the rational validator. Ultimately, the rational validator will receive fewer rewards.